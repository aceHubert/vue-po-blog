(window["webpackJsonpVueUieditor"]=window["webpackJsonpVueUieditor"]||[]).push([["chunk-2d0c7eb0"],{5351:function(n,e,t){"use strict";t.r(e),t.d(e,"ExtraLib",(function(){return d}));var r="\n\ntype Constructor = {\n  new (...args: any[]): any;\n}\n\n// we don't support infer props in async component\n// N.B. ComponentOptions<V> is contravariant, the default generic should be bottom type\ntype Component<Data=DefaultData<never>, Methods=DefaultMethods<never>, Computed=DefaultComputed, Props=DefaultProps> =\n  | typeof Vue\n  | FunctionalComponentOptions<Props>\n  | ComponentOptions<never, Data, Methods, Computed, Props>\n\ninterface EsModuleComponent {\n  default: Component\n}\n\ntype AsyncComponent<Data=DefaultData<never>, Methods=DefaultMethods<never>, Computed=DefaultComputed, Props=DefaultProps>\n  = AsyncComponentPromise<Data, Methods, Computed, Props>\n  | AsyncComponentFactory<Data, Methods, Computed, Props>\n\ntype AsyncComponentPromise<Data=DefaultData<never>, Methods=DefaultMethods<never>, Computed=DefaultComputed, Props=DefaultProps> = (\n  resolve: (component: Component<Data, Methods, Computed, Props>) => void,\n  reject: (reason?: any) => void\n) => Promise<Component | EsModuleComponent> | void;\n\ntype AsyncComponentFactory<Data=DefaultData<never>, Methods=DefaultMethods<never>, Computed=DefaultComputed, Props=DefaultProps> = () => {\n  component: AsyncComponentPromise<Data, Methods, Computed, Props>;\n  loading?: Component | EsModuleComponent;\n  error?: Component | EsModuleComponent;\n  delay?: number;\n  timeout?: number;\n}\n\n/**\n * When the Computed type parameter on ComponentOptions is inferred,\n * it should have a property with the return type of every get-accessor.\n * Since there isn't a way to query for the return type of a function, we allow TypeScript\n * to infer from the shape of Accessors<Computed> and work backwards.\n */\ntype Accessors<T> = {\n  [K in keyof T]: (() => T[K]) | ComputedOptions<T[K]>\n}\n\ntype DataDef<Data, Props, V> = Data | ((this: Readonly<Props> & V) => Data)\n/**\n * This type should be used when an array of strings is used for a component's props value.\n */\ntype ThisTypedComponentOptionsWithArrayProps<V extends Vue, Data, Methods, Computed, PropNames extends string> =\n  object &\n  ComponentOptions<V, DataDef<Data, Record<PropNames, any>, V>, Methods, Computed, PropNames[], Record<PropNames, any>> &\n  ThisType<CombinedVueInstance<V, Data, Methods, Computed, Readonly<Record<PropNames, any>>>>;\n\n/**\n * This type should be used when an object mapped to PropOptions is used for a component's props value.\n */\ntype ThisTypedComponentOptionsWithRecordProps<V extends Vue, Data, Methods, Computed, Props> =\n  object &\n  ComponentOptions<V, DataDef<Data, Props, V>, Methods, Computed, RecordPropsDefinition<Props>, Props> &\n  ThisType<CombinedVueInstance<V, Data, Methods, Computed, Readonly<Props>>>;\n\ntype DefaultData<V> =  object | ((this: V) => object);\ntype DefaultProps = Record<string, any>;\ntype DefaultMethods<V> =  { [key: string]: (this: V, ...args: any[]) => any };\ntype DefaultComputed = { [key: string]: any };\ninterface ComponentOptions<\n  V extends Vue,\n  Data=DefaultData<V>,\n  Methods=DefaultMethods<V>,\n  Computed=DefaultComputed,\n  PropsDef=PropsDefinition<DefaultProps>,\n  Props=DefaultProps> {\n  data?: Data;\n  props?: PropsDef;\n  propsData?: object;\n  computed?: Accessors<Computed>;\n  methods?: Methods;\n  watch?: Record<string, WatchOptionsWithHandler<any> | WatchHandler<any> | string>;\n\n  el?: Element | string;\n  template?: string;\n  // hack is for functional component type inference, should not be used in user code\n  render?(createElement: CreateElement, hack: RenderContext<Props>): VNode;\n  renderError?(createElement: CreateElement, err: Error): VNode;\n  staticRenderFns?: ((createElement: CreateElement) => VNode)[];\n\n  beforeCreate?(this: V): void;\n  created?(): void;\n  beforeDestroy?(): void;\n  destroyed?(): void;\n  beforeMount?(): void;\n  mounted?(): void;\n  beforeUpdate?(): void;\n  updated?(): void;\n  activated?(): void;\n  deactivated?(): void;\n  errorCaptured?(err: Error, vm: Vue, info: string): boolean | void;\n  serverPrefetch?(this: V): Promise<void>;\n\n  directives?: { [key: string]: DirectiveFunction | DirectiveOptions };\n  components?: { [key: string]: Component<any, any, any, any> | AsyncComponent<any, any, any, any> };\n  transitions?: { [key: string]: object };\n  filters?: { [key: string]: Function };\n\n  provide?: object | (() => object);\n  inject?: InjectOptions;\n\n  model?: {\n    prop?: string;\n    event?: string;\n  };\n\n  parent?: Vue;\n  mixins?: (ComponentOptions<Vue> | typeof Vue)[];\n  name?: string;\n  extends?: ComponentOptions<Vue> | typeof Vue;\n  delimiters?: [string, string];\n  comments?: boolean;\n  inheritAttrs?: boolean;\n}\n\ninterface FunctionalComponentOptions<Props = DefaultProps, PropDefs = PropsDefinition<Props>> {\n  name?: string;\n  props?: PropDefs;\n  model?: {\n    prop?: string;\n    event?: string;\n  };\n  inject?: InjectOptions;\n  functional: boolean;\n  render?(this: undefined, createElement: CreateElement, context: RenderContext<Props>): VNode | VNode[];\n}\n\ninterface RenderContext<Props=DefaultProps> {\n  props: Props;\n  children: VNode[];\n  slots(): any;\n  data: VNodeData;\n  parent: Vue;\n  listeners: { [key: string]: Function | Function[] };\n  scopedSlots: { [key: string]: NormalizedScopedSlot };\n  injections: any\n}\n\ntype Prop<T> = { (): T } | { new(...args: any[]): T & object } | { new(...args: string[]): Function }\n\ntype PropType<T> = Prop<T> | Prop<T>[];\n\ntype PropValidator<T> = PropOptions<T> | PropType<T>;\n\ninterface PropOptions<T=any> {\n  type?: PropType<T>;\n  required?: boolean;\n  default?: T | null | undefined | (() => T | null | undefined);\n  validator?(value: T): boolean;\n}\n\ntype RecordPropsDefinition<T> = {\n  [K in keyof T]: PropValidator<T[K]>\n}\ntype ArrayPropsDefinition<T> = (keyof T)[];\ntype PropsDefinition<T> = ArrayPropsDefinition<T> | RecordPropsDefinition<T>;\n\ninterface ComputedOptions<T> {\n  get?(): T;\n  set?(value: T): void;\n  cache?: boolean;\n}\n\ntype WatchHandler<T> = (val: T, oldVal: T) => void;\n\ninterface WatchOptions {\n  deep?: boolean;\n  immediate?: boolean;\n}\n\ninterface WatchOptionsWithHandler<T> extends WatchOptions {\n  handler: WatchHandler<T>;\n}\n\ninterface DirectiveBinding extends Readonly<VNodeDirective> {\n  readonly modifiers: { [key: string]: boolean };\n}\n\ntype DirectiveFunction = (\n  el: HTMLElement,\n  binding: DirectiveBinding,\n  vnode: VNode,\n  oldVnode: VNode\n) => void;\n\ninterface DirectiveOptions {\n  bind?: DirectiveFunction;\n  inserted?: DirectiveFunction;\n  update?: DirectiveFunction;\n  componentUpdated?: DirectiveFunction;\n  unbind?: DirectiveFunction;\n}\n\ntype InjectKey = string | symbol;\n\ntype InjectOptions = {\n  [key: string]: InjectKey | { from?: InjectKey, default?: any }\n} | string[];\n\ntype PluginFunction<T> = (Vue: typeof _Vue, options?: T) => void;\n\ninterface PluginObject<T> {\n  install: PluginFunction<T>;\n  [key: string]: any;\n}\n\ntype ScopedSlot = (props: any) => ScopedSlotReturnValue;\ntype ScopedSlotReturnValue = VNode | string | boolean | null | undefined | ScopedSlotReturnArray;\ninterface ScopedSlotReturnArray extends Array<ScopedSlotReturnValue> {}\n\n// Scoped slots are guaranteed to return Array of VNodes starting in 2.6\ntype NormalizedScopedSlot = (props: any) => ScopedSlotChildren;\ntype ScopedSlotChildren = VNode[] | undefined;\n\n// Relaxed type compatible with $createElement\ntype VNodeChildren = VNodeChildrenArrayContents | [ScopedSlot] | string | boolean | null | undefined;\ninterface VNodeChildrenArrayContents extends Array<VNodeChildren | VNode> {}\n\ninterface VNode {\n  tag?: string;\n  data?: VNodeData;\n  children?: VNode[];\n  text?: string;\n  elm?: Node;\n  ns?: string;\n  context?: Vue;\n  key?: string | number;\n  componentOptions?: VNodeComponentOptions;\n  componentInstance?: Vue;\n  parent?: VNode;\n  raw?: boolean;\n  isStatic?: boolean;\n  isRootInsert: boolean;\n  isComment: boolean;\n}\n\ninterface VNodeComponentOptions {\n  Ctor: typeof Vue;\n  propsData?: object;\n  listeners?: object;\n  children?: VNode[];\n  tag?: string;\n}\n\ninterface VNodeData {\n  key?: string | number;\n  slot?: string;\n  scopedSlots?: { [key: string]: ScopedSlot | undefined };\n  ref?: string;\n  refInFor?: boolean;\n  tag?: string;\n  staticClass?: string;\n  class?: any;\n  staticStyle?: { [key: string]: any };\n  style?: string | object[] | object;\n  props?: { [key: string]: any };\n  attrs?: { [key: string]: any };\n  domProps?: { [key: string]: any };\n  hook?: { [key: string]: Function };\n  on?: { [key: string]: Function | Function[] };\n  nativeOn?: { [key: string]: Function | Function[] };\n  transition?: object;\n  show?: boolean;\n  inlineTemplate?: {\n    render: Function;\n    staticRenderFns: Function[];\n  };\n  directives?: VNodeDirective[];\n  keepAlive?: boolean;\n}\n\ninterface VNodeDirective {\n  name: string;\n  value?: any;\n  oldValue?: any;\n  expression?: any;\n  arg?: string;\n  oldArg?: string;\n  modifiers?: { [key: string]: boolean };\n}\n\ninterface CreateElement {\n  (tag?: string | Component<any, any, any, any> | AsyncComponent<any, any, any, any> | (() => Component), children?: VNodeChildren): VNode;\n  (tag?: string | Component<any, any, any, any> | AsyncComponent<any, any, any, any> | (() => Component), data?: VNodeData, children?: VNodeChildren): VNode;\n}\n\nclass Vue {\n  readonly $el: Element;\n  readonly $options: ComponentOptions<Vue>;\n  readonly $parent: Vue;\n  readonly $root: Vue;\n  readonly $children: Vue[];\n  readonly $refs: { [key: string]: Vue | Element | Vue[] | Element[] };\n  readonly $slots: { [key: string]: VNode[] | undefined };\n  readonly $scopedSlots: { [key: string]: NormalizedScopedSlot | undefined };\n  readonly $isServer: boolean;\n  readonly $data: Record<string, any>;\n  readonly $props: Record<string, any>;\n  readonly $ssrContext: any;\n  readonly $vnode: VNode;\n  readonly $attrs: Record<string, string>;\n  readonly $listeners: Record<string, Function | Function[]>;\n\n  $mount(elementOrSelector?: Element | string, hydrating?: boolean): this;\n  $forceUpdate(): void;\n  $destroy(): void;\n  $set: typeof Vue.set;\n  $delete: typeof Vue.delete;\n  $watch(\n    expOrFn: string,\n    callback: (this: this, n: any, o: any) => void,\n    options?: WatchOptions\n  ): (() => void);\n  $watch<T>(\n    expOrFn: (this: this) => T,\n    callback: (this: this, n: T, o: T) => void,\n    options?: WatchOptions\n  ): (() => void);\n  $on(event: string | string[], callback: Function): this;\n  $once(event: string | string[], callback: Function): this;\n  $off(event?: string | string[], callback?: Function): this;\n  $emit(event: string, ...args: any[]): this;\n  $nextTick(callback: (this: this) => void): void;\n  $nextTick(): Promise<void>;\n  $createElement: CreateElement;\n  \n}\n\ntype CombinedVueInstance<Instance extends Vue, Data, Methods, Computed, Props> =  Data & Methods & Computed & Props & Instance;\ntype ExtendedVue<Instance extends Vue, Data, Methods, Computed, Props> = VueConstructor<CombinedVueInstance<Instance, Data, Methods, Computed, Props> & Vue>;\n\ninterface VueConfiguration {\n  silent: boolean;\n  optionMergeStrategies: any;\n  devtools: boolean;\n  productionTip: boolean;\n  performance: boolean;\n  errorHandler(err: Error, vm: Vue, info: string): void;\n  warnHandler(msg: string, vm: Vue, trace: string): void;\n  ignoredElements: (string | RegExp)[];\n  keyCodes: { [key: string]: number | number[] };\n  async: boolean;\n}\n\ninterface VueConstructor<V extends Vue = Vue> {\n  new <Data = object, Methods = object, Computed = object, PropNames extends string = never>(options?: ThisTypedComponentOptionsWithArrayProps<V, Data, Methods, Computed, PropNames>): CombinedVueInstance<V, Data, Methods, Computed, Record<PropNames, any>>;\n  // ideally, the return type should just contain Props, not Record<keyof Props, any>. But TS requires to have Base constructors with the same return type.\n  new <Data = object, Methods = object, Computed = object, Props = object>(options?: ThisTypedComponentOptionsWithRecordProps<V, Data, Methods, Computed, Props>): CombinedVueInstance<V, Data, Methods, Computed, Record<keyof Props, any>>;\n  new (options?: ComponentOptions<V>): CombinedVueInstance<V, object, object, object, Record<keyof object, any>>;\n\n  extend<Data, Methods, Computed, PropNames extends string = never>(options?: ThisTypedComponentOptionsWithArrayProps<V, Data, Methods, Computed, PropNames>): ExtendedVue<V, Data, Methods, Computed, Record<PropNames, any>>;\n  extend<Data, Methods, Computed, Props>(options?: ThisTypedComponentOptionsWithRecordProps<V, Data, Methods, Computed, Props>): ExtendedVue<V, Data, Methods, Computed, Props>;\n  extend<PropNames extends string = never>(definition: FunctionalComponentOptions<Record<PropNames, any>, PropNames[]>): ExtendedVue<V, {}, {}, {}, Record<PropNames, any>>;\n  extend<Props>(definition: FunctionalComponentOptions<Props, RecordPropsDefinition<Props>>): ExtendedVue<V, {}, {}, {}, Props>;\n  extend(options?: ComponentOptions<V>): ExtendedVue<V, {}, {}, {}, {}>;\n\n  nextTick<T>(callback: (this: T) => void, context?: T): void;\n  nextTick(): Promise<void>\n  set<T>(object: object, key: string | number, value: T): T;\n  set<T>(array: T[], key: number, value: T): T;\n  delete(object: object, key: string | number): void;\n  delete<T>(array: T[], key: number): void;\n\n  directive(\n    id: string,\n    definition?: DirectiveOptions | DirectiveFunction\n  ): DirectiveOptions;\n  filter(id: string, definition?: Function): Function;\n\n  component(id: string): VueConstructor;\n  component<VC extends VueConstructor>(id: string, constructor: VC): VC;\n  component<Data, Methods, Computed, Props>(id: string, definition: AsyncComponent<Data, Methods, Computed, Props>): ExtendedVue<V, Data, Methods, Computed, Props>;\n  component<Data, Methods, Computed, PropNames extends string = never>(id: string, definition?: ThisTypedComponentOptionsWithArrayProps<V, Data, Methods, Computed, PropNames>): ExtendedVue<V, Data, Methods, Computed, Record<PropNames, any>>;\n  component<Data, Methods, Computed, Props>(id: string, definition?: ThisTypedComponentOptionsWithRecordProps<V, Data, Methods, Computed, Props>): ExtendedVue<V, Data, Methods, Computed, Props>;\n  component<PropNames extends string>(id: string, definition: FunctionalComponentOptions<Record<PropNames, any>, PropNames[]>): ExtendedVue<V, {}, {}, {}, Record<PropNames, any>>;\n  component<Props>(id: string, definition: FunctionalComponentOptions<Props, RecordPropsDefinition<Props>>): ExtendedVue<V, {}, {}, {}, Props>;\n  component(id: string, definition?: ComponentOptions<V>): ExtendedVue<V, {}, {}, {}, {}>;\n\n  use<T>(plugin: PluginObject<T> | PluginFunction<T>, options?: T): VueConstructor<V>;\n  use(plugin: PluginObject<any> | PluginFunction<any>, ...options: any[]): VueConstructor<V>;\n  mixin(mixin: VueConstructor | ComponentOptions<Vue>): VueConstructor<V>;\n  compile(template: string): {\n    render(createElement: typeof Vue.prototype.$createElement): VNode;\n    staticRenderFns: (() => VNode)[];\n  };\n\n  observable<T>(obj: T): T;\n\n  config: VueConfiguration;\n  version: string;\n}\n\nconst Vue: VueConstructor;\n",o="\ntype Dictionary < T > = { [key: string]: T }\ntype ErrorHandler = (err: Error) => void\n\ntype RouterMode = 'hash' | 'history' | 'abstract'\ntype RawLocation = string | Location\ntype RedirectOption = RawLocation | ((to: Route) => RawLocation)\ntype NavigationGuard < V extends Vue = Vue > = (\n  to: Route,\n  from: Route,\n  next: (to?: RawLocation | false | ((vm: V) => any) | void) => void\n) => any\n\ndeclare class VueRouter {\n  constructor(options?: RouterOptions)\n\n  app: Vue\n  mode: RouterMode\n  currentRoute: Route\n\n  beforeEach(guard: NavigationGuard): Function\n  beforeResolve(guard: NavigationGuard): Function\n  afterEach(hook: (to: Route, from: Route) => any): Function\n  push(location: RawLocation): Promise<Route>\n  replace(location: RawLocation): Promise<Route>\n  push(\n    location: RawLocation,\n    onComplete?: Function,\n    onAbort?: ErrorHandler\n  ): void\n  replace(\n    location: RawLocation,\n    onComplete?: Function,\n    onAbort?: ErrorHandler\n  ): void\n  go(n: number): void\n  back(): void\n  forward(): void\n  getMatchedComponents(to?: RawLocation | Route): Component[]\n  onReady(cb: Function, errorCb?: ErrorHandler): void\n  onError(cb: ErrorHandler): void\n  addRoutes(routes: RouteConfig[]): void\n  resolve(\n    to: RawLocation,\n    current?: Route,\n    append?: boolean\n  ): {\n    location: Location\n    route: Route\n    href: string\n    // backwards compat\n    normalizedTo: Location\n    resolved: Route\n  }\n\n  static install: PluginFunction<never>\n}\n\ntype Position = { x: number; y: number }\ntype PositionResult = Position | { selector: string; offset?: Position } | void\n\ninterface RouterOptions {\n  routes?: RouteConfig[]\n  mode?: RouterMode\n  fallback?: boolean\n  base?: string\n  linkActiveClass?: string\n  linkExactActiveClass?: string\n  parseQuery?: (query: string) => Object\n  stringifyQuery?: (query: Object) => string\n  scrollBehavior?: (\n    to: Route,\n    from: Route,\n    savedPosition: Position | void\n  ) => PositionResult | Promise<PositionResult> | undefined | null\n}\n\ntype RoutePropsFunction = (route: Route) => Object\n\ninterface PathToRegexpOptions {\n  sensitive?: boolean\n  strict?: boolean\n  end?: boolean\n}\n\ninterface RouteConfig {\n  path: string\n  name?: string\n  component?: Component\n  components?: Dictionary<Component>\n  redirect?: RedirectOption\n  alias?: string | string[]\n  children?: RouteConfig[]\n  meta?: any\n  beforeEnter?: NavigationGuard\n  props?: boolean | Object | RoutePropsFunction\n  caseSensitive?: boolean\n  pathToRegexpOptions?: PathToRegexpOptions\n}\n\ninterface RouteRecord {\n  path: string\n  regex: RegExp\n  components: Dictionary<Component>\n  instances: Dictionary<Vue>\n  name?: string\n  parent?: RouteRecord\n  redirect?: RedirectOption\n  matchAs?: string\n  meta: any\n  beforeEnter?: (\n    route: Route,\n    redirect: (location: RawLocation) => void,\n    next: () => void\n  ) => any\n  props:\n    | boolean\n    | Object\n    | RoutePropsFunction\n    | Dictionary<boolean | Object | RoutePropsFunction>\n}\n\ninterface Location {\n  name?: string\n  path?: string\n  hash?: string\n  query?: Dictionary<string | (string | null)[] | null | undefined>\n  params?: Dictionary<string>\n  append?: boolean\n  replace?: boolean\n}\n\ninterface Route {\n  path: string\n  name?: string | null\n  hash: string\n  query: Dictionary<string | (string | null)[]>\n  params: Dictionary<string>\n  fullPath: string\n  matched: RouteRecord[]\n  redirectedFrom?: string\n  meta?: any\n}\n",a="\ndeclare type UEVueMixin<V extends Vue = Vue> = ComponentOptions<Vue> | typeof Vue;\ninterface UEVueComponentOptions<V extends Vue> extends ComponentOptions<V> {\n}\ndeclare function UEMergeMixin<V extends Vue = Vue>(mixin1: UEVueMixin<V>, mixin2: UEVueMixin<V>): UEVueMixin<V>;\ndeclare function UEVueComponent<V extends Vue>(options: UEVueComponentOptions<V> & ThisType<V>): <VC extends VueClass<V>>(target: VC) => VC;\n/**\n * UEProp(String)\n * @param options\n * @returns\n */\ndeclare function UEVueProp(options?: (PropOptions | Constructor[] | Constructor)): PropertyDecorator;\n/**\n  * 定义 Inject\n  * @param provide\n  * @example\n  *  UEVueProvide('ppName')\n  *  private _tstPo() {\n  *      return this.name + 'asdfasf';\n  *  }\n  *\n  */\ndeclare function UEVueProvide(provide?: string): PropertyDecorator;\n/**\n * 注入 Provide\n * @param provide\n * @param defaultValue\n * @example\n *  UEVueInject('ppName')\n    private _ppName:any;\n */\ndeclare function UEVueInject(provide?: string, defaultValue?: any): PropertyDecorator;\n/**\n * vue data\n * @example\n *   UEVueData()\n *   private _initData1() {\n *       this.name1 = '11111';\n *       this.name2 = '2222';\n *      return {name3: '3333'};\n *   }\n */\ndeclare function UEVueData(): PropertyDecorator;\n/**\n * UEProp(String)\n * @param options\n * @returns\n */\ndeclare function UETransFn(fn: any): MethodDecorator;\n/**\n *\n * @param path\n * @param options\n * @param change\n * @returns\n * @example\n * UEVueWatch('name')\n * private _wName(val){}\n */\ndeclare function UEVueWatch<T = UEVue>(path: string | ((this: T) => any), options?: WatchOptions, change?: boolean): MethodDecorator;\ndeclare type UEVueLifeName = 'beforeCreate' | 'created' | 'beforeMount' | 'mounted' | 'beforeDestroy' | 'destroyed' | 'beforeUpdate' | 'updated' | 'activated' | 'deactivated' | 'beforeRouteEnter' | 'beforeRouteUpdate' | 'beforeRouteLeave';\n/**\n * vue data\n * @example\n *   UEVueLife('created')\n *   private _created1() {\n *   }\n */\ndeclare function UEVueLife(lifeName: UEVueLifeName, after?: boolean): PropertyDecorator;\n/**\n *\n * @param event 事件名称\n * @param once 是否只触发一次\n * @param el 是否绑定到el\n */\ndeclare function UEVueEvent<T = UEVue>(event: string, once?: boolean, el?: ((this: T, el: HTMLElement) => HTMLElement | Document | Window) | boolean): PropertyDecorator;\n/**\n *\n * @param event 事件名称\n * @param p 选项\n * @param el 是否绑定到el\n */\ndeclare function UEVueEvent<T = UEVue>(event: string, p?: {\n    /** 是否只触发一次，默认为false */\n    once?: boolean;\n    /** 是否路由activated才触发, 如果有el参数默认为true 否则为 false */\n    activated?: boolean;\n}, el?: ((this: T, el: HTMLElement) => HTMLElement | Document | Window) | boolean): PropertyDecorator;\n/**\n * 影射到v-model value 值\n * @param change change(self, val, oldVal):void\n * @example UEVueValue() id:string = '';\n */\ndeclare function UEVueValue<T>(change?: (self: T, val: any, oldVal: any) => void): (target: any, propKey: string) => void;\ndeclare class UEVue extends Vue {\n    static getVueName(vnode: any): any;\n    get $vueName(): string;\n    readonly props: void;\n    readonly store: void;\n    readonly beforeCreate: void;\n    readonly created: void;\n    readonly beforeMount: void;\n    readonly mounted: void;\n    readonly beforeDestroy: void;\n    readonly destroyed: void;\n    readonly beforeUpdate: void;\n    readonly updated: void;\n    readonly activated: void;\n    readonly deactivated: void;\n    readonly computed: void;\n    readonly beforeRouteEnter: void;\n    readonly beforeRouteUpdate: void;\n    readonly beforeRouteLeave: void;\n    readonly render: () => any;\n    readonly _render: () => any;\n    private value;\n    /** 获取或设置值 */\n    get $value(): any;\n    set $value(value: any);\n    get $isDestroyed(): boolean;\n    get $isBeingDestroyed(): boolean;\n    get $isMounted(): boolean;\n    get $isRouteActived(): boolean;\n}\n\n",i="\ndeclare type UEObject = {\n  [key: string]: any;\n};\ninterface UEOption {\n  /** vue 组合，扩展到组件内部，如：组件、指令或方法等 */\n  mixins?: UEVueMixin[];\n  /** 转换器，定义json的渲染行为 和 定义组件在编辑时的行为属性 */\n  transfer?: UETransfer;\n  /** 设置模板到编辑器左边树 */\n  templates?: UETemplate[];\n  /** 编辑器设置 */\n  readonly editor?: {\n      [type: string]: UETransferEditor;\n  };\n  /** 转换器处理之前 */\n  transferBefore?: (render: UERenderItem, extend?: UETransferExtend) => UERenderItem;\n  /** 转换器处理之后 */\n  transferAfter?: (render: UERenderItem, extend?: UETransferExtend) => UERenderItem;\n  /** 扩展代码智能提示声明 */\n  extraLib?(): Promise<string>;\n  /** 添加全局变量，object对象 */\n  global?(): UEObject;\n  /** 设置http对象 */\n  http?(): UEHttpRequest;\n  /** 是否开启 babel 在线编译（要加载babel-standalone js），默认为 true */\n  babel?: boolean;\n  /** 是否已初始化 */\n  readonly inited?: boolean;\n}\n\ntype UEHttpRequestConfig = {\n  url?:string;\n  method?:string;\n  data?: any;\n  query?: any;\n  [key: string]: any;\n};\n\ntype UEHttpRequest = {\n  get?(url: string, config?: UEHttpRequestConfig): Promise<any>;\n  delete?(url: string, config?: UEHttpRequestConfig): Promise<any>;\n  head?(url: string, config?: UEHttpRequestConfig): Promise<any>;\n  post?(url: string, config?: UEHttpRequestConfig): Promise<any>;\n  put?(url: string, config?: UEHttpRequestConfig): Promise<any>;\n  patch?(url: string, config?: UEHttpRequestConfig): Promise<any>;\n  [key: string]: (url: string, config?: UEHttpRequestConfig) => Promise<any>;\n};\n\ndeclare type UETransferExtend = {\n  /** Vue 初始化数据 */\n  data?: UEObject;\n  /** 编辑中 */\n  readonly editing?: boolean;\n  readonly service?: UEService;\n  readonly editor?: UETransferEditor;\n  /** 当前 render */\n  readonly render?: UERenderItem;\n  /** 全局变量 */\n  global?: any;\n  readonly options?: UEOption;\n  /**\n   * 添加 mixin\n   * @param mixin\n   * @param before\n   */\n  extendMixin(mixin: UEVueMixin, before?: boolean): any;\n  /**\n   * 设置prop内容\n   * @param name\n   * @param content\n   */\n  setProp(name: string, content: RenderProp): RenderProp;\n  /**\n   * 获取prop内容\n   * @param name\n   * @param remove 获取后是否删除\n   */\n  getProp(name: string, remove?: boolean): RenderProp;\n  /**\n   * 删除属性\n   * @param name\n   */\n  removeProp(name: string): void;\n  /**\n   * 获取prop值\n   * @param name\n   * @param remove  获取后是否删除\n   */\n  getPropValue(name: string, remove?: boolean): any;\n  setPropValue(name: string, content: RenderProp): any;\n  /**\n   * 获取prop text内容，如果bind返回 {{text}}\n   * @param name\n   * @param remove  获取后是否删除\n   */\n  getPropText(name: string, defaultValue?: any, remove?: boolean): any;\n  /**\n   * 向上查找节点，包括自己\n   * @param find 查找条件，默认上一级节点\n   */\n  closest(find: (render: UERenderItem) => boolean): UERenderItem;\n};\ndeclare type RenderProp = {\n  bind?: boolean;\n  has?: boolean;\n  event?: boolean;\n  name: string;\n  value?: any;\n};\ninterface UETransferEditorAttrsItem {\n  /** render属性props名称，一般与key相同，请参考transition appear事件与属性的定义 */\n  readonly name?: string;\n  /** 定义attr的key */\n  readonly key?: string;\n  /** 是否自定义属性，属性栏自定义的属性，可删除的属性 */\n  readonly cust?: boolean;\n  /** 显示名称 */\n  text?: string;\n  /** 默认值 */\n  value?: any;\n  /** 编辑时代替value，保证组件编辑时的显示效果和防止使用value时出错 */\n  demoValue?: any;\n  /** 进入高级代码编写时，使用些属性代替 value 属性 */\n  editValue?: string | {\n      get(): any;\n      set(val: any): void;\n  };\n  /** 是否默认代码编辑按钮，默认为: true */\n  codeBtn?: boolean;\n  placeholder?: string;\n  /** 描述 */\n  desc?: string;\n  /** 代码编辑器的语言，javascript, typescript, ts, css */\n  language?: string;\n  row?: boolean;\n  /** 分组 */\n  group?: string;\n  /** 分组顺序，同组第一个为准 */\n  groupOrder?: number;\n  /** 顺序 */\n  order?: number;\n  /** 是否显示属性，默认：true */\n  show?: boolean;\n  /** 是否事件，默认：false */\n  event?: boolean;\n  /** 是否vue属性，默认：false */\n  vue?: boolean;\n  /** 是否在编辑时生效，默认：false */\n  effect?: boolean;\n  /** 此属性只使用于编辑器，即最终结果没有此属性 */\n  editorOlny?: boolean;\n  /** 显示类型，默认：text，custom为自定义（弹出对话框） */\n  type?: 'text' | 'slider' | 'select' | 'select-only' | 'boolean' | 'boolean-only' | 'number' | 'custom';\n  /** 显示类型的参数 */\n  typeOption?: any;\n  /** 数据源, string[] | {text:string;value:string;} */\n  datas?: any[] | ((p: {\n      attr: UETransferEditorAttrsItem;\n      attrs: UETransferEditorAttrs;\n      service: UEService;\n  }) => any[]);\n  /** 是否为bind属性，默认为 false */\n  bind?: boolean;\n  /** 是否允许编辑bind属性, 默认 true */\n  enabledBind?: boolean;\n  /** 编辑是否使用bind，默认: false */\n  editorBind?: boolean;\n  /** 是否支持 codeEditor, 不是全部属性支持，默认为: true */\n  codeEditor?: boolean;\n  /** 是否默认vue-def 内容，只在vue-def使用, 默认：false */\n  isVueDef?: boolean;\n  /** 点击时处理，返回false中断，type为custom时生效 */\n  click?(attr: UETransferEditorAttrsItem, service: UEService): Promise<boolean> | boolean;\n  /** 改变时处理，返回false中断 */\n  change?(attr: UETransferEditorAttrsItem, service: UEService): Promise<boolean> | boolean;\n  /** 是否已初始化 */\n  readonly inited?: boolean;\n}\ninterface UETransferEditorAttrs {\n  [key: string]: UETransferEditorAttrsItem;\n}\ninterface UETransferEditor {\n  /** 显示名称, 支持环境变量, 如:%label% */\n  text?: string | ((p: {\n      editor: UETransferEditor;\n      attrs: UETransferEditorAttrs;\n  }) => string);\n  /** 如果text为空时默认内容 */\n  defaultText?: string;\n  /** 格式化 text */\n  textFormat?(editor: UETransferEditor, attrs: UETransferEditorAttrs): string;\n  /** 名称 */\n  readonly name?: string;\n  placeholder?: string;\n  icon?: string;\n  /** 默认的模板内容(JSON) */\n  json?: UERenderItem;\n  /** 默认的模板内容 */\n  template?: string;\n  /** 排序，默认：99 */\n  order?: number;\n  /** 分组，可用\"/\"实现分组层级，如：基础库/基础组件 */\n  group?: string;\n  /** 分组顺序 */\n  groupOrder?: number;\n  /** 是否容器组件（可以插入子节点），默认为 false */\n  container?: boolean;\n  /** 是否显示容器边框，默认为 false */\n  containerBorder?: boolean;\n  /** 是否在左边留空方便控制 */\n  controlLeft?: boolean;\n  /** 是否基础组件，编辑时作为独立组件，内容不能拖动，默认：true */\n  base?: boolean;\n  /** 编辑时使用div代替显示 */\n  empty?: string;\n  /** 是否可以收起，容器时默认为 true */\n  collapse?: boolean;\n  /** 编辑时临时添加样式 */\n  className?: string | ((p: {\n      render: UERenderItem;\n      editor: UETransferEditor;\n      attrs: UETransferEditorAttrs;\n  }) => string);\n  /** 是否可以选中（编辑），默认：true */\n  select?: boolean;\n  /** 是否可以拖动（编辑），默认：true */\n  draggable?: boolean;\n  /** 是否显示在组件树，默认为 true */\n  showInTree?: boolean;\n  /** 编辑时是否显示 */\n  show?: boolean;\n  /** 编辑时是否强制显示为inline */\n  inline?: boolean;\n  /** 是否有placeholder属性， 默认为:false */\n  placeholderAttr?: boolean;\n  /** 是否有 disabled 属性， 默认为:false */\n  disabledAttr?: boolean;\n  /** 处理是否可以复制 */\n  coping?: (p: {\n      render: UERenderItem;\n      parent: UERenderItem;\n      service: UEService;\n  }) => boolean;\n  /** 是否可以拖动组件为子节点，容器时才会生产 */\n  contenting?: (p: {\n      /** 当前render(父层) */\n      fromRender: UERenderItem;\n      /** 移动到 render */\n      toRender: UERenderItem;\n      /** 当前render的editort */\n      fromEditor: UETransferEditor;\n      /** 移动到 render 的editort*/\n      toEditor: UETransferEditor;\n      /** 容器render(父层) */\n      fromParent: UERenderItem;\n      /** 容器render(父层) */\n      toParent: UERenderItem;\n      service: UEService;\n  }) => boolean;\n  /** 拖动时处理，返回true|false，决定是否可以拖动到目标 */\n  moving?: (p: {\n      /** 当前render(父层) */\n      fromRender: UERenderItem;\n      /** 移动到 render */\n      toRender: UERenderItem;\n      /** 当前render的editort */\n      fromEditor: UETransferEditor;\n      /** 移动到 render 的editort*/\n      toEditor: UETransferEditor;\n      /** 容器render(父层) */\n      fromParent: UERenderItem;\n      /** 容器render(父层) */\n      toParent: UERenderItem;\n      type2?: UEDragType2;\n      service: UEService;\n  }) => boolean;\n  /** 是否可以移动子节点 */\n  movingChild?: (p: {\n      /** 当前render(父层) */\n      fromRender: UERenderItem;\n      /** 移动到 render */\n      toRender: UERenderItem;\n      /** 当前render的editort */\n      fromEditor: UETransferEditor;\n      /** 移动到 render 的editort*/\n      toEditor: UETransferEditor;\n      /** 容器render(父层) */\n      fromParent: UERenderItem;\n      /** 容器render(父层) */\n      toParent: UERenderItem;\n      service: UEService;\n  }) => boolean;\n  /**\n   * 编辑渲染时转换 render 和 attr\n   */\n  transferAttr?: (p: {\n      render: UERenderItem;\n      attrs: UETransferEditorAttrs;\n      editor: UETransferEditor;\n      editing: boolean;\n      service: UEService;\n  }) => void;\n  /**\n   * 选中对像的快捷菜单\n   */\n  contextmenu?: (p: {\n      render: UERenderItem;\n      attrs: UETransferEditorAttrs;\n      editor: UETransferEditor;\n      service: UEService;\n  }) => UEContextmenuItem[];\n  /**\n   * 选中对像的工具栏\n   */\n  toolbar?: (p: {\n      render: UERenderItem;\n      attrs: UETransferEditorAttrs;\n      editor: UETransferEditor;\n      service: UEService;\n  }) => UEContextmenuItem[];\n  /** 隐藏attr，如: ['class'] */\n  hideAttrs?: string[];\n  /** 隐藏attr group，如: ['Vue'] */\n  hideAttrGroups?: string[];\n  /** 属性栏 */\n  attrs?: UETransferEditorAttrs;\n  /** 是否已初始化 */\n  readonly inited?: boolean;\n}\ninterface UETransferItem {\n  /** 组件名称 */\n  type?: string;\n  /** 默认属性 */\n  props?: UEObject;\n  /** 编辑器配置 */\n  editor?: UETransferEditor;\n  /**\n   * 渲染时转换 render, 如果返回空不渲染\n   */\n  transfer?: (render: UERenderItem, extend?: UETransferExtend) => UERenderItem;\n  /** 是否已初始化 */\n  readonly inited?: boolean;\n}\ninterface UETransfer {\n  [key: string]: UETransferItem;\n}\n/**\n* 获取 ExtraLib 智能提示声明内容\n*/\ndeclare function UEGetExtraLib(): Promise<string>;\ninterface UETemplate {\n  /**\n   * 分组\n   */\n  group?: string;\n  /**\n   * 分组顺序，同分组的第一个groupOrder生效\n   */\n  groupOrder?: number;\n  /**\n   * 标题\n   */\n  title?: string;\n  icon?: string;\n  /**\n   * 描述\n   */\n  desc?: string;\n  /**\n   * json 模板，可以json字串或json对像\n   */\n  json?: string | UEObject;\n  /**\n   * html 模板，如果有json内容，优先使用json内容\n   */\n  template?: string;\n  /** 拖动时处理，返回true|false，决定是否可以拖动到目标 */\n  moving?: (p: {\n      /** 移动到 render */\n      toRender: UERenderItem;\n      /** 移动到 render 的editort*/\n      toEditor: UETransferEditor;\n      fromEditor: UETransferEditor;\n      /** 容器render(父层) */\n      toParent: UERenderItem;\n      type2?: UEDragType2;\n      service: UEService;\n  }) => boolean;\n}\ndeclare type UEThemeMode = 'json' | 'script' | 'tmpl';\ndeclare type UEMode = UEThemeMode | 'design' | 'json' | 'script' | 'tmpl' | 'preview' | 'other';\ninterface UEThemeEvent {\n  item: any;\n  event: any;\n  service: UEService;\n}\ninterface UEToolBar {\n  title?: string;\n  icon?: string;\n  divided?: boolean;\n  disabled?: boolean | ((e: UEThemeEvent) => boolean);\n  show?: boolean | ((e: UEThemeEvent) => boolean);\n  /** 点击, 返回 false 不处理默认行为 */\n  click?(e: UEThemeEvent): void | boolean | Promise<void | boolean>;\n}\ninterface UETheme {\n  /**\n   * 设置关于对话框内容\n   * @param p\n   */\n  about?(p: {\n      service: UEService;\n  }): string | (Promise<string>);\n  /**\n   * 编辑器可用模式：'json' | 'script' | 'tmpl\n   */\n  modes?: UEThemeMode[];\n  /** 设置顶部工具栏 */\n  toolBar?: UEToolBar[];\n  /** 选中组件的添加快捷菜单 */\n  contextmenus?(p: {\n      render: UERenderItem;\n      parent: UERenderItem;\n      editor: UETransferEditor;\n      service: UEService;\n  }): UEContextmenuItem[];\n}\ndeclare type UEDragType = 'in' | 'top' | 'bottom' | 'left' | 'right';\ndeclare type UEDragType2 = 'in' | 'before' | 'after';\n/** 标记为不能选择 */\ndeclare const UECanNotSelectProps = \"ue-cant-select\";\n/** 标记为不能移动 */\ndeclare const UECanNotMoveProps = \"ue-cant-move\";\n/** 标记为不能删除 */\ndeclare const UECanNotRemoveProps = \"ue-cant-remove\";\n/** 标记为不能复制 */\ndeclare const UECanNotCopyProps = \"ue-cant-copy\";\n/** 标记为不能选择子节点 */\ndeclare const UECanNotSelectChildProps = \"ue-cant-select-child\";\n/** 标记为不能移动子节点 */\ndeclare const UECanNotMoveChildProps = \"ue-cant-move-child\";\n/** 标记为不能删除子节点 */\ndeclare const UECanNotRemoveChildProps = \"ue-cant-remove-child\";\n/** 标记为不能复制子节点 */\ndeclare const UECanNotCopyChildProps = \"ue-cant-copy-child\";\n/** 标记为不能移入子节点 */\ndeclare const UECanNotMoveInProps = \"ue-cant-movein\";\n/** 标记为不能移出子节点 */\ndeclare const UECanNotMoveOutProps = \"ue-cant-moveout\";\n/** 标记节点是否锁定 */\ndeclare const UEIsLockProps = \"ue-is-lock\";\n/** 标记节点是否折叠 */\ndeclare const UEIsCollapseProps = \"ue-is-collapse\";\n/**\n* 删除 ue 私有特殊属性，如：ue-cant-move\n* @param props\n*/\ndeclare function UEClearPrivateProps(props: any): void;\n/**\n* 是否不能标示属性名称\n* @param name\n*/\ndeclare function UEIsCanNotProps(name: string): boolean;\n/**\n* 是否不能操作\n* @param render\n* @param cantName 标记名称, 如：UECanNotSelectProps\n*/\ndeclare function UEIsCanNot(render: any, cantName: string): any;\ndeclare class UECompiler {\n  static toTemplate(items: (UERenderItem | string)[], editing?: boolean): string;\n  static vueCompile(template: string): {\n      render(createElement: any): VNode;\n      staticRenderFns: (() => VNode)[];\n  };\n  static vueTemplateCompiler(template: string): Promise<CompiledResult<string>>;\n  static compile(template: string | UERenderItem, debugInfo?: any, editing?: boolean): Promise<{\n      render: any;\n      staticRenderFns: any[];\n  }>;\n  static isEqual(p1: any, p2: any): boolean;\n  /** render to code(script) */\n  static renderToScriptJson(render: UERenderItem): string;\n  /** code(script) render */\n  static scriptJsonToRender(obj: string): UERenderItem;\n  /**\n   * Html 转成 Render\n   * @param html\n   */\n  static htmlToRenderAsync(html: string): Promise<string | UERenderItem>;\n  /**\n   * Html 转成 Render\n   * @param html\n   */\n  static htmlToRender(html: string): Promise<string | UERenderItem>;\n  private static _htmlToRender;\n  /**\n   * Render 转成 Html\n   * @param html\n   */\n  static renderToHtml(render: UERenderItem, config?: UEJsonToHtmlConfig): string;\n  /**\n   * Html 转成 Json\n   * @param html\n   */\n  static htmlToJsonAsync(html: string): Promise<any>;\n  /**\n   * Html 转成 Json，注意先使用 UECompiler 初始化\n   * @param html\n   */\n  static htmlToJson(html: string): any;\n  /**\n   * Json 转成 Html\n   * @param html\n   */\n  static jsonToHtmlAsync(json: any, config?: UEJsonToHtmlConfig): Promise<string>;\n  /**\n   * Json 转成 Html，注意先使用 UECompiler 初始化\n   * @param html\n   */\n  static jsonToHtml(json: any, config?: UEJsonToHtmlConfig): string;\n  /**\n   * 初始babel环境\n   */\n  static init(p?: {\n      bable?: boolean;\n  }): Promise<((html: string) => any[])[]>;\n  /**\n   * 使用 babel 编译，注意先使用 UECompiler 初始化\n   * @param script 脚本内容\n   * @param opt babel 参数\n   */\n  static babelTransform(script: string, opt?: any): {\n      code: string;\n      ast: any;\n      [key: string]: any;\n  };\n  /**\n   * 使用 babel 编译，返回一个fun name与code，注意先使用 UECompiler 初始化\n   * @param script 脚本内容\n   * @param hasRet 是否有返回值\n   * @param opt babel 参数\n   */\n  static babelTransformToFun(script: string, hasRet?: boolean, opt?: any): {\n      code: string;\n      ast: any;\n      fnName: string;\n  };\n  /**\n   * 使用 babel 编译，返回一个fun name与code，注意先使用 UECompiler 初始化\n   * @param args 新方法的参数名称，如：['name', 'id']\n   * @param script 脚本内容\n   * @param withThis with(this)\n   * @param opt babel 参数\n   * @example babelTransformToFunEx(['name', 'id'], 'return {name, id}')()\n   */\n  static babelTransformToFunEx(args: string[], script: string, withThis?: boolean, opt?: any): Function;\n  /**\n   * 使用 babel 编译，不用 UECompiler 初始化，直接可以使用\n   * @param strcipt 脚本内容\n   * @param opt babel 参数\n   */\n  static babelTransformAsync(script: string, opt?: any): Promise<{\n      [key: string]: any;\n      code: string;\n      ast: any;\n  }>;\n}\ndeclare class UEHelper {\n  static stringEmpty: string;\n  static noop(): void;\n  static error(...args: any[]): void;\n  /** 深 assign */\n  static assignDepth(...objs: any[]): any;\n  static isWindow(obj: any): boolean;\n  /**\n   * 比较两个对像是否相等，但不比较function类型\n   * @param p1\n   * @param p2\n   */\n  static isEqualNotFn(p1: any, p2: any): boolean;\n  static toArray(p: any, start?: number, count?: number): Array<any>;\n  static makeAutoId(): string;\n  /**\n   * 是否属于类或基类\n   * @param p 参数\n   * @param cls 类\n   */\n  static isClass(p: any, cls: any): boolean;\n  static offset(element: HTMLElement, offset?: {\n      top: number;\n      left: number;\n  }): {\n      top: number;\n      left: number;\n  };\n  /**\n   * setQuerystring\n   * @param url\n   * @param p\n   * @param json 如果为true , 属性内容 Array 或 Object 转为JSON, 默认为 false\n   * @param useToHttp 是否用于http，encode会不一样 , 默认为 false\n   */\n  static setQuerystring(url: string, p: object, json?: boolean, useToHttp?: boolean): string;\n  /**\n   * 获取url query, 如果name为空返回query部分\n   * @param url\n   * @param name\n   */\n  static getQuerystring(url: string, name?: string): string;\n  static queryParse(query: string): object;\n  /**\n   *\n   * @param query\n   * @param useToHttp 是否用于http，encode会不一样 , 默认为 false\n   */\n  static queryStringify(query: any, useToHttp?: boolean): string;\n  /**\n   * setHashQuerystring\n   * @param url\n   * @param p\n   * @param json 如果为true , 属性内容 Array 或 Object 转为JSON, 默认为 false\n   */\n  static setHashQuerystring(url: string, p: object, json?: boolean): string;\n  /**\n   * 获取url hash query, 如果name为空返回query部分\n   * @param url\n   * @param name\n   */\n  static getHashQuerystring(url: string, name?: string): string;\n  /**\n   * 获取 url hash部分\n   * @param url\n   */\n  static getUrlHash(url: string): string;\n  /**\n   * 获取url路径部分\n   * @param url\n   */\n  static getUrlPart(url: string): string;\n  /**\n   * url 是否绝对路径\n   * @param url\n   */\n  static isAbsolutelyUrl(url: string): boolean;\n  /**\n   * 发送一个事件\n   * @param element HTML Element\n   * @param eventName 事件名称\n   * @param type 事件类型，默认 MouseEvents\n   * @param bubbles 是否可以取消，默认 true\n   * @param cancelable 是否可以取消，默认 true\n   */\n  static dispatchEvent(element: Element | EventTarget, eventName: string, type?: \"UIEvents\" | \"MouseEvents\" | \"MutationEvents\" | \"HTMLEvents\", bubbles?: boolean, cancelable?: boolean): void;\n  /**\n   * 统一 await 返回值: [err, data]\n   * @param promise\n   */\n  static awaitWrap<T = any, U = any>(promise: Promise<T>): Promise<[U | null, T | null]>;\n  /**\n   * 暂停\n   * @param time 微秒\n   */\n  static pause(time: any): Promise<unknown>;\n}\ndeclare class UERender {\n  /**\n   * 将元数据转为vue 元数据\n   * @param renders\n   * @param extend\n   */\n  static JsonToVueRender(renders: UERenderItem[], extend: UETransferExtend, parentRender?: UERenderItem): UERenderItem[];\n  /**\n   * 添加公共模板，传入参数会被亏染\n   * @param options\n   * @param transfer\n   */\n  static AddGlobalTemplates(templates: UETemplate[]): void;\n  /**\n   * 添加公共 transfer，传入参数会被亏染\n   * @param options\n   * @param transfer\n   */\n  static AddGlobalTransfer(...transfers: UETransfer[]): void;\n  /** 将公共内容放到option */\n  static GlobalToOptions(options: UEOption): UEOption;\n  /**\n   * 添加新的 transfer 到 options，传入参数会被亏染\n   * @param options\n   * @param transfer\n   */\n  static AddTransfer(options: UEOption, transfer: UETransfer): UEOption;\n  /**\n   * 定义 options，传入参数会被亏染\n   * @param options\n   */\n  static DefineOption(options: UEOption): UEOption;\n  /**\n   * 定义 transfer，传入参数会被亏染\n   * @param transfer\n   */\n  static DefineTransfer(transfer: UETransfer): UETransfer;\n  /**\n   * 定义 transfer.editor，传入参数会被亏染\n   * @param type\n   * @param editor\n   */\n  static DefineTransferEditor(type: string, editor: UETransferEditor): UETransferEditor;\n  /**\n   * 定义 transfer.editor.attr，传入参数会被亏染\n   * @param name\n   * @param attr\n   * @param editor\n   */\n  static DefineTransferEditorAttr(name: string, attr: UETransferEditorAttrsItem, editor: UETransferEditor): UETransferEditorAttrsItem;\n  /**\n   * 新建一个自定义attr\n   * @param name\n   * @param attr\n   * @param editor\n   */\n  static NewCustAttr(name: string, attr: UETransferEditorAttrsItem, editor: UETransferEditor): UETransferEditorAttrsItem;\n  static newEditValue(fnName: string): {\n      get(): any;\n      set(val: any): void;\n  };\n  static findRender(renders: UERenderItem[], p: any): UERenderItem;\n  static getVueBindName(name: string): string;\n  static getVueBindNameEx(name: string): {\n      isBind: boolean;\n      isEvent: boolean;\n      name: string;\n  };\n  static makeExportDefault(content: string): string;\n  static removeExportDefault(content: string): string;\n}\ninterface UERenderItem {\n  /** 标签类型 */\n  type?: string;\n  /** 属性 */\n  props?: any;\n  /** 子节点 */\n  children?: (UERenderItem | string)[];\n  /** 是否创建此节点，默认为 true */\n  isRender?: boolean;\n  /** 获取父节点 */\n  parent?(): UERenderItem;\n  content?: string;\n  /** 编辑时的ID */\n  readonly editorId?: string;\n  /** 编辑时的 parent ID */\n  readonly editorPId?: string;\n  /** 编辑器组件配置 */\n  readonly editor?: UETransferEditor;\n  /**\n   * 存放临时内容\n   */\n  readonly temp?: UEObject;\n  /** 编辑器组件属性配置 */\n  readonly attrs?: UETransferEditorAttrs;\n  /** 编辑器设计时使用 */\n  'editor-attrs'?: any;\n}\ndeclare type MonacoEditorContext = {\n  content?: string;\n  extraLib?: string;\n  formatAuto?: boolean;\n  show?: boolean;\n  language?: \"javascript\" | 'json' | 'html' | 'css';\n  save?(content?: string): Promise<void> | void;\n  close?(): Promise<void> | void;\n};\ndeclare type UEAddComponent = {\n  id?: string;\n  $isTmpl?: boolean;\n  uedrag?: boolean;\n  icon?: string;\n  title?: string;\n  type?: string;\n  item: any;\n};\ndeclare class UEService {\n  readonly $uieditor: UEVue;\n  constructor($uieditor: UEVue, options: UEOption);\n  private _options;\n  get options(): UEOption;\n  set options(options: UEOption);\n  _destroy(): void;\n  $emit(event: string, ...arg: any[]): void;\n  $on(event: string, callback: Function): void;\n  /** 历史记录 */\n  history: {\n      list: any[];\n      curList: any[];\n      pos: number;\n      max: number;\n      init: boolean;\n      canNext: boolean;\n      canPre: boolean;\n      _cacle: () => void;\n      add: (item: any) => void;\n      addCur: () => void;\n      next: () => Promise<void>;\n      pre: () => Promise<void>;\n  };\n  /** 当前处理内容 */\n  current: {\n      /** 当前选中Id */\n      id: string;\n      /** 当前选中parentId */\n      parentId: string;\n      /** 根Id */\n      rootId: string;\n      /** 面包屑 */\n      breadcrumbs: any[];\n      /** 是否属性栏 */\n      refreshAttr: boolean;\n      /** 编辑中的属性栏 */\n      attrs: any;\n      /** 编辑中的editor内容 */\n      editor: any;\n      /** 用于显示的vue mixin */\n      mixin: any;\n      /** 计算后用于显示的JSON */\n      json: any;\n      /** 模式：design, json, script, tmpl, preview */\n      mode: UEMode;\n      monacoEditor: MonacoEditorContext;\n      monacoEditorOther: MonacoEditorContext;\n  };\n  private _clearMonacoEditor;\n  setModeUI(mode: UEMode): void;\n  setMode(mode: UEMode): Promise<void>;\n  /**\n   * 打开代码编辑\n   * @param option\n   */\n  showMonacoEditorOther(option: MonacoEditorContext): Promise<void>;\n  getTmpl(): string;\n  setTmpl(html: any): Promise<void>;\n  getScript(): string;\n  setScript(script: string): Promise<void>;\n  /** 获取预览参数 */\n  getPreviewOpt(): string;\n  setPreviewOpt(content: string): Promise<void>;\n  showPreviewOpt(): void;\n  private _resetCurrent;\n  /** 编辑中的JSON */\n  private _editJson;\n  /** 编辑中的 root JSON，注意：不是完整JSON内容，如：collapse 后，子节点给删除了。 */\n  get rootRender(): UERenderItem;\n  setJson(json: UERenderItem): Promise<any>;\n  _lastcp: Vue;\n  private _setJson;\n  getRenderItem(id: string, context?: UERenderItem): UERenderItem;\n  /**\n * 根据 type 获取 render\n * @param type\n * @param render 如果不为空，从些render开始查找\n */\n  getRenderByType(type: string, context?: UERenderItem): UERenderItem;\n  /**\n   * 获取当前render\n   */\n  getCurRender(): UERenderItem;\n  /**\n   * 获取父节点\n   * @param render\n   * @param all 是否所有内容，否则根据select设置查找父节点，默认为：true\n   */\n  getParentRenderItem(render: UERenderItem, all?: boolean): UERenderItem;\n  getParentRenderByType(render: UERenderItem, type: string): any;\n  closest(render: UERenderItem, fn: (render: UERenderItem) => boolean): any;\n  empty(cnf?: boolean): Promise<void>;\n  /**\n   * 获取 render 的临时内容，使用内容传送\n   * @param id\n   * @param key\n   */\n  getRenderTemp(id: string, key: string): any;\n  /**\n   * 获取 render 的临时内容，使用内容传送\n   * @param render\n   * @param key\n   */\n  getRenderTemp(render: UERenderItem, key: string): any;\n  /**\n   * 设置 render 的临时内容(不会生成meta)，使用内容传送\n   * @param id\n   * @param key\n   * @param value\n   */\n  setRenderTemp(id: string, key: string, value: any): any;\n  /**\n   * 设置 render 的临时内容(不会生成meta)，使用内容传送\n   * @param render\n   * @param key\n   * @param value\n   */\n  setRenderTemp(render: UERenderItem, key: string, value: any): any;\n  /**\n   * 刷新导向栏\n   * @param render\n   */\n  refresBreadcrumbs(render?: UERenderItem): void;\n  private _makeBreadcrumbs;\n  /**\n   * 根据component创建render\n   * @param type\n   * @param parentId\n   */\n  private createRender;\n  /**\n   * 修改 render type(类型)\n   * @param render\n   * @param type\n   */\n  changeRenderType(render: UERenderItem, type: string): void;\n  /**\n   *\n   * @param cnf 是否要确认\n   * @param norefresh 是否刷新\n   */\n  delCur(cnf?: boolean, norefresh?: boolean): Promise<void>;\n  /** norefresh 是否刷新 */\n  deleteWidget(parentId: string, id: string, norefresh?: boolean): void;\n  getAttr(id: string, key: string): UETransferEditorAttrsItem;\n  /**\n   * 根据id， 设置render属性\n   * @param id\n   * @param attr\n   */\n  setAttr(id: string, attr: UETransferEditorAttrsItem, refresh?: boolean): Promise<void>;\n  /**\n   * 添加属性\n   * @param id\n   * @param attrName\n   */\n  addAttr(id: string, attrName: string): UETransferEditorAttrsItem;\n  /**\n   * 返回编辑最终render，保存时用\n   * @param editing 是否编辑中的render， 默认：false\n   * @param id 返回指定render内容\n   */\n  getJson(editing?: boolean, id?: string): any;\n  /**\n   * 返回编辑最终render，保存时用\n   * @param editing 是否编辑中的render， 默认：false\n   * @param render 返回指定render内容\n   */\n  getJson(editing?: boolean, render?: UERenderItem): any;\n  private _isRrefreshing;\n  /**\n   * 刷新编辑内容\n   * @param formHistory\n   */\n  refresh(): Promise<any>;\n  _currentTimeId: any;\n  /**\n   * 设置（选择）当前render\n   * @param render\n   */\n  setCurrent(render: UERenderItem): any;\n  /**\n   * 根据id，设置（选择）当前render\n   * @param id\n   */\n  setCurrent(id: string): any;\n  refeshSelectBox(): void;\n  private _components;\n  private _components_tree;\n  /** 组件栏数据 */\n  get components(): {\n      list: any[];\n      tree: any[];\n  };\n  /**\n   * 通过拖动添加\n   * @param cpId\n   * @param renderId\n   * @param type2\n   */\n  addByDrag(cpId: string, renderId: string, type2: UEDragType2): Promise<void>;\n  canAddByDrag(cpId: string, renderId: string, type2: UEDragType2): boolean;\n  /**\n   * 通过类型添加\n   * @param type\n   * @param renderId\n   * @param type2\n   */\n  addByType(type: string, renderId: string, type2: UEDragType2): Promise<void>;\n  /**\n   * 通过JSON添加\n   * @param json\n   * @param renderId\n   * @param type2\n   */\n  addByJson(json: any, renderId: string, type2: UEDragType2): Promise<void>;\n  /**\n   * 通过模板添加\n   * @param json\n   * @param renderId\n   * @param type2\n   */\n  addByTmpl(template: string, renderId: string, type2: UEDragType2): Promise<void>;\n  /**\n   * 添加组件 或 模板\n   * @param component\n   * @param renderId\n   * @param type2\n   */\n  addByComponent(component: UEAddComponent, renderId: string, type2: UEDragType2): Promise<any>;\n  isLocked(render: UERenderItem): boolean;\n  isLocked(id: string): boolean;\n  locked(render: UERenderItem, locked: boolean): Promise<any>;\n  locked(id: string, locked: boolean): Promise<any>;\n  isCollapse(render: UERenderItem): boolean;\n  isCollapse(id: string): boolean;\n  collapse(render: UERenderItem, isCollapse: boolean): Promise<any>;\n  collapse(id: string, isCollapse: boolean): Promise<any>;\n  canRemove(render: UERenderItem): boolean;\n  canRemove(id: string): boolean;\n  canCopy(render: UERenderItem): boolean;\n  canCopy(id: string): boolean;\n  canSelect(render: UERenderItem): boolean;\n  canSelect(id: string): boolean;\n  canMove(fromId: string, toId: string, type2: UEDragType2): boolean;\n  move(fromId: string, toId: string, type2: string): Promise<any>;\n  private _copyId;\n  private _copyParentId;\n  private _isCut;\n  copyCur(): void;\n  copyCurToNext(): void;\n  /** 剪切 */\n  cutCur(): void;\n  get canPaste(): boolean;\n  pasteCur(pos?: 'before' | 'after' | 'child', keepCur?: boolean, currentId?: string, focus?: boolean): void;\n  private selectById;\n  selectNext(): void;\n  selectPre(): void;\n  selectParent(): void;\n  selectChild(): void;\n  foucs(): void;\n}\n\n",s="\n\ndeclare function UEEditorVueDef(def:UEVueMixin):UEVueMixin;\n\ndeclare function UEPreviewOptionDef(p:{\n  /** 模拟 $query */\n  query:any;\n  /** 模拟 $param */\n  param:any;\n  /** 模拟 vue def */\n  vueDef:UEVueMixin;\n}):any;\n\n",d="\n"+r+"\n"+o+"\n"+a+"\n"+i+"\n"+s+"\n"}}]);